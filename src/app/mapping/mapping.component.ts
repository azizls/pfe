import { Component, OnInit } from '@angular/core';
import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';
import * as Papa from 'papaparse';
import * as XLSX from 'xlsx';
import { DatabaseService } from '../services/database.service';

interface TableMapping {
  excelColumn: string;
  dbColumn: string;
  // Optionnel : pour lookup dans une dimension
  lookupTable?: string;
  lookupColumn?: string | undefined;
}

interface TableData {
  name: string;
  mapping: TableMapping[];
  data: any[];
}

@Component({
  selector: 'app-mapping',
  templateUrl: './mapping.component.html',
  styleUrls: ['./mapping.component.scss']
})
export class MappingComponent implements OnInit {
  databaseName: string = '';
  availableTables: string[] = [];
  selectedTable: string = '';
  dbColumnsMap: { [table: string]: string[] } = {};
  excelColumns: string[] = [];
  filePreview: any[] = [];
  fullData: any[] = [];
  // Sauvegarde des donn√©es Excel originales pour la fact
  excelDataBackup: any[] = [];
  mappings: TableMapping[] = [];
  tablesData: TableData[] = [];
  showJson: boolean = false;
  selectedFile: File | null = null;

  constructor(private databaseService: DatabaseService) {}

  ngOnInit(): void {}

  toggleJson(): void {
    this.showJson = !this.showJson;
  }

  fetchTables(): void {
    if (this.databaseName.trim() !== '') {
      this.databaseService.getTables(this.databaseName).subscribe(
        (result: any) => {
          this.availableTables = Object.keys(result);
          this.dbColumnsMap = result;
          // R√©initialiser pour un nouveau mapping
          this.selectedTable = '';
          this.mappings = [];
          this.fullData = [];
          this.excelDataBackup = [];
          console.log('‚úÖ Tables r√©cup√©r√©es:', this.availableTables);
        },
        (error: any) => {
          console.error('‚ùå Erreur lors de la r√©cup√©ration des tables', error);
        }
      );
    } else {
      this.availableTables = [];
      this.selectedTable = '';
    }
  }

  onFileSelected(event: any): void {
    this.selectedFile = event.target.files[0];
    if (!this.selectedFile) return;

    if (this.selectedFile.type === 'text/csv' || this.selectedFile.name.endsWith('.csv')) {
      Papa.parse(this.selectedFile, {
        header: true,
        complete: (results) => {
          this.excelColumns = results.meta.fields || [];
          this.filePreview = results.data.slice(0, 5);
          this.fullData = results.data;
          // Sauvegarder les donn√©es originales pour la fact
          this.excelDataBackup = [...this.fullData];
          console.log('‚úÖ Colonnes extraites du CSV:', this.excelColumns);
          console.log('‚úÖ Aper√ßu des donn√©es:', this.filePreview);
          console.log('‚úÖ Donn√©es compl√®tes charg√©es:', this.fullData);
        },
        error: (err) => console.error('‚ùå Erreur lors du parsing CSV:', err)
      });
    } else if (this.selectedFile.name.endsWith('.xlsx') || this.selectedFile.name.endsWith('.xls')) {
      const reader = new FileReader();
      reader.onload = (e: any) => {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }) as any[][];
        if (jsonData.length) {
          this.excelColumns = jsonData[0] as string[];
          this.filePreview = jsonData.slice(1, 6).map(row => this.mapRowToObj(row));
          this.fullData = jsonData.slice(1).map(row => this.mapRowToObj(row));
          // Sauvegarder les donn√©es originales pour la fact
          this.excelDataBackup = [...this.fullData];
          console.log('‚úÖ Colonnes extraites de l\'Excel:', this.excelColumns);
          console.log('‚úÖ Aper√ßu des donn√©es:', this.filePreview);
          console.log('‚úÖ Donn√©es compl√®tes charg√©es:', this.fullData);
        } else {
          console.error('‚ùå Le fichier Excel est vide.');
        }
      };
      reader.readAsArrayBuffer(this.selectedFile);
    } else {
      console.error('‚ùå Type de fichier non support√©.');
    }
  }

  reloadFile(): void {
    if (this.selectedFile) {
      console.log('üîÑ Rechargement du fichier:', this.selectedFile.name);
      const fakeEvent = { target: { files: [this.selectedFile] } };
      this.onFileSelected(fakeEvent);
    } else {
      console.warn("‚ö†Ô∏è Aucun fichier √† recharger.");
    }
  }

  mapRowToObj(row: any[]): any {
    const obj: any = {};
    this.excelColumns.forEach((col, index) => {
      obj[col] = row[index];
    });
    return obj;
  }

  drop(event: CdkDragDrop<string[]>): void {
    if (event.previousContainer !== event.container) {
      const draggedColumn = event.item.data;
      const targetColumn = event.container.data[event.currentIndex];
      if (this.selectedTable) {
        const exists = this.mappings.find(m => m.dbColumn === targetColumn);
        if (!exists) {
          this.mappings.push({ excelColumn: draggedColumn, dbColumn: targetColumn });
        } else {
          this.mappings = this.mappings.map(m =>
            m.dbColumn === targetColumn ? { excelColumn: draggedColumn, dbColumn: targetColumn } : m
          );
        }
        console.log('‚úÖ Mapping enregistr√©:', { excelColumn: draggedColumn, dbColumn: targetColumn });
      }
    } else {
      moveItemInArray(event.container.data, event.previousIndex, event.currentIndex);
    }
  }

  // Enregistrer le mapping et les donn√©es pour une dimension
  // On passe le nom de la table en param√®tre afin de le conserver avant r√©initialisation
  saveTableMapping(tableName: string): void {
    if (!tableName || this.mappings.length === 0 || this.fullData.length === 0) {
      console.error("‚ùå Table non s√©lectionn√©e, mapping vide ou aucune donn√©e.");
      return;
    }
    console.log(`üìå Enregistrement du mapping pour ${tableName}...`);
    // Supprimer l'ancien mapping pour cette table
    this.tablesData = this.tablesData.filter(t => t.name !== tableName);
    // Ajouter le nouveau mapping et les donn√©es
    this.tablesData.push({
      name: tableName,
      mapping: [...this.mappings],
      data: [...this.fullData]
    });
    console.log("‚úÖ Mapping enregistr√©, √©tat actuel de tablesData:", JSON.stringify(this.tablesData, null, 2));
    // R√©initialiser uniquement le mapping (les donn√©es Excel restent disponibles)
    this.mappings = [];
  }

  // Charger et envoyer une dimension (le mapping saisi par l'utilisateur)
  loadAndSendDimension(): void {
    console.log("üìå V√©rification avant envoi:");
    console.log("selectedTable:", this.selectedTable);
    console.log("mappings:", this.mappings);
    console.log("fullData:", this.fullData);
    if (!this.selectedTable || this.mappings.length === 0 || this.fullData.length === 0) {
      console.error("‚ùå Table non s√©lectionn√©e, mapping vide ou donn√©es absentes.");
      alert("‚ö†Ô∏è Veuillez s√©lectionner une table, d√©finir un mapping et charger des donn√©es.");
      return;
    }
    // Conserver la table actuellement s√©lectionn√©e avant r√©initialisation
    const currentTable = this.selectedTable;
    // Sauvegarder ce mapping dans tablesData
    this.saveTableMapping(currentTable);
    const tableToSend = this.tablesData.find(t => t.name === currentTable);
    if (!tableToSend || tableToSend.data.length === 0) {
      console.error(`‚ùå La table ${currentTable} n'existe pas dans tablesData ou n'a pas de donn√©es.`);
      alert(`‚ùå La table ${currentTable} n'est pas correctement enregistr√©e.`);
      return;
    }
    const jsonOutput = {
      databaseName: this.databaseName,
      table: tableToSend.name,
      mapping: tableToSend.mapping,
      data: tableToSend.data
    };
    console.log(`üì§ Envoi de la dimension ${tableToSend.name}...`, JSON.stringify(jsonOutput, null, 2));
    this.databaseService.insertDimensionData(jsonOutput).subscribe(
      (response: any) => {
        console.log(`‚úÖ Insertion r√©ussie pour ${tableToSend.name}`, response);
        alert(`‚úÖ Dimension ${tableToSend.name} ins√©r√©e avec succ√®s !`);
        // R√©initialisation apr√®s envoi r√©ussi (les donn√©es Excel restent pour r√©utilisation)
        this.selectedTable = '';
        this.mappings = [];
        setTimeout(() => {
          this.reloadFile();
        }, 4000);
      },
      (error: any) => {
        console.error(`‚ùå Erreur lors de l‚Äôinsertion de ${tableToSend.name}`, error);
        alert(`‚ùå Erreur lors de l‚Äôinsertion de ${tableToSend.name}`);
      }
    );
  }

  // Auto-g√©n√©ration du mapping pour la fact √† partir des dimensions enregistr√©es
  autoGenerateFactMapping(): TableMapping[] {
    const factMappingMap: { [dim: string]: TableMapping } = {};
    // Pour chaque dimension enregistr√©e (tablesData dont le nom ne commence pas par "fact")
    this.tablesData.forEach(dim => {
      if (!dim.name.toLowerCase().startsWith("fact")) {
        const dimKey = dim.name.toLowerCase();
        if (!factMappingMap[dimKey]) {
          // Choisir le mapping qui contient "id" dans le dbColumn si disponible, sinon le premier
          let candidate: TableMapping = dim.mapping[0];
          for (const m of dim.mapping) {
            if (m.dbColumn.toLowerCase().includes("id")) {
              candidate = m;
              break;
            }
          }
          factMappingMap[dimKey] = {
            excelColumn: candidate.excelColumn,
            dbColumn: `${dim.name.toLowerCase()}_id`,
            lookupTable: dim.name,
            lookupColumn: candidate.dbColumn
          };
        }
      }
    });
    const mappingArray = Object.values(factMappingMap);
    console.log("üîç Auto-mapping g√©n√©r√© pour la fact:", mappingArray);
    return mappingArray;
  }

  // Charger et envoyer la fact de mani√®re automatique
  sendFactTable(): void {
    // Rechercher la table fact parmi les tables disponibles (nom commen√ßant par "fact")
    const factTableName = this.availableTables.find(t => t.toLowerCase().startsWith("fact"));
    if (!factTableName) {
      console.error("‚ùå Aucune table fact d√©finie dans la base de donn√©es.");
      alert("‚ùå Aucune table fact trouv√©e.");
      return;
    }
    // Essayer de r√©cup√©rer les donn√©es de la fact depuis tablesData
    let factTableData = this.tablesData.find(t => t.name.toLowerCase() === factTableName.toLowerCase());
    if (!factTableData) {
      // Si aucune donn√©e fact n'est enregistr√©e, utiliser les donn√©es Excel originales sauvegard√©es
      factTableData = {
        name: factTableName,
        mapping: this.autoGenerateFactMapping(),
        data: [...this.excelDataBackup]
      };
      // Ajouter √† tablesData pour r√©f√©rence future
      this.tablesData.push(factTableData);
    }
    if (!factTableData.data || factTableData.data.length === 0) {
      console.error("‚ùå La table Fact est vide ou non renseign√©e.");
      alert("‚ùå La table Fact n'a pas de donn√©es.");
      return;
    }
    const jsonOutput = {
      databaseName: this.databaseName,
      factTable: factTableData.name,
      mapping: factTableData.mapping,
      data: factTableData.data
    };
    console.log("üì§ Envoi de la table Fact...", JSON.stringify(jsonOutput, null, 2));
    this.databaseService.insertFactData(jsonOutput).subscribe(
      (response: any) => {
        console.log("‚úÖ Table Fact ins√©r√©e avec succ√®s !", response);
        alert("‚úÖ Fact ins√©r√©e avec succ√®s !");
      },
      (error: any) => {
        console.error("‚ùå Erreur lors de l‚Äôinsertion de la table Fact", error);
        alert("‚ùå Erreur lors de l‚Äôinsertion de la table Fact");
      }
    );
  }

  onTableSelected(): void {
    // R√©initialiser le mapping et les donn√©es lors de la s√©lection d'une nouvelle table
    this.mappings = [];
    this.fullData = [];
    this.filePreview = [];
    console.log(`üìå Table s√©lectionn√©e : ${this.selectedTable}, r√©initialisation du mapping.`);
  }
}
